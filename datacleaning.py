import pandas as pd
import numpy as np
import re
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.neighbors import KNeighborsClassifier

# ----------- RULE-BASED CLEANING -----------
def rule_based(df):
    for col in ["FirstName", "LastName", "Street", "City", "State", "Email", "ZipCode"]:
        if col in df.columns:
            df[col] = df[col].astype(str).str.strip()
    if "compare" in df.columns:
        df.drop("compare", axis=1, inplace=True)
    if "ZipCode" in df.columns:
        zip_pattern = r'^\d{5}$'
        mask = ~df["ZipCode"].astype(str).str.match(zip_pattern)
        df.loc[mask, "ZipCode"] = "invalid"
    if "Bonus" in df.columns:
        df["Bonus"] = df["Bonus"].astype(str)
        bonus_num = pd.to_numeric(df["Bonus"], errors="coerce")
        df.loc[(bonus_num < 0) | (bonus_num.isna()), "Bonus"] = "invalid"
    return df

# ----------- ISOLATION FOREST ANOMALY DETECTION -----------
def ml_based(df):
    df["DateOfBirth"] = pd.to_datetime(df.get("DateOfBirth"), errors="coerce")
    df["DateOfEntryService"] = pd.to_datetime(df.get("DateOfEntryService"), errors="coerce")
    df["BasePay"] = pd.to_numeric(df.get("BasePay"), errors="coerce")
    df["Bonus"] = pd.to_numeric(df.get("Bonus"), errors="coerce")
    df["YearsOfService"] = (df["DateOfEntryService"] - df["DateOfBirth"]).dt.days / 365.25

    df_input = df[["BasePay", "Bonus", "YearsOfService"]].dropna()
    idx_model = df_input.index

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(df_input)

    iso = IsolationForest(contamination=0.05, random_state=42)
    pred = iso.fit_predict(X_scaled)

    df["IsAnomaly"] = 0
    df.loc[idx_model, "IsAnomaly"] = (pred == -1).astype(int)
    df["AnomalyType"] = "Normal"
    df.loc[df["IsAnomaly"] == 1, "AnomalyType"] = "IsolationForest"

    return df

# ----------- EMAIL & FULLNAME GENERATION + KNN IMPUTATION -----------
def missing_values(df):
    df_missing = df.copy()
    original = df[["FullName", "Email"]].copy() if "FullName" in df.columns else df[["Email"]].copy()

    rng = np.random.default_rng(seed=42)
    mask_email = rng.choice([True, False], size=len(df), p=[0.05, 0.95])
    df_missing.loc[mask_email, "Email"] = np.nan

    if "FullName" in df.columns:
        mask_full = rng.choice([True, False], size=len(df), p=[0.05, 0.95])
        df_missing.loc[mask_full, "FullName"] = np.nan
        df_missing["FullName_gen"] = df_missing["FullName"].fillna(
            df_missing["FirstName"].str.strip() + " " + df_missing["LastName"].str.strip()
        )

    # Prepare KNN imputing for Email
    train = df_missing[df_missing["Email"].notna()]
    test = df_missing[df_missing["Email"].isna()]

    all_fn = pd.concat([train["FirstName"], test["FirstName"]], axis=0).dropna().unique()
    all_ln = pd.concat([train["LastName"], test["LastName"]], axis=0).dropna().unique()

    le_fn = LabelEncoder().fit(all_fn)
    le_ln = LabelEncoder().fit(all_ln)

    X_train = pd.DataFrame({
        "fn": le_fn.transform(train["FirstName"]),
        "ln": le_ln.transform(train["LastName"])
    })
    y_train = train["Email"]

    knn = KNeighborsClassifier(n_neighbors=3)
    knn.fit(X_train, y_train)

    X_test = pd.DataFrame({
        "fn": le_fn.transform(test["FirstName"]),
        "ln": le_ln.transform(test["LastName"])
    })
    df_missing.loc[test.index, "Email_gen"] = knn.predict(X_test)
    df_missing["Email_gen"].fillna(df_missing["Email"], inplace=True)

    # Calculate email generation success rate
    email_success = 0.0
    if "Email" in original.columns:
        email_success = (df_missing.loc[mask_email, "Email_gen"] == original.loc[mask_email, "Email"]).mean() * 100

    # Mark anomalies generated by incorrect KNN predictions
    mask_wrong_email = mask_email & (df_missing["Email_gen"] != original["Email"])
    df_missing.loc[mask_wrong_email, "IsAnomaly"] = 1
    df_missing.loc[mask_wrong_email, "AnomalyType"] = "KNN"

	# Count how many emails were generated using KNN
    emails_generated = df_missing.loc[mask_email, "Email_gen"].notna().sum()
    print(f"Total emails generated using KNN: {emails_generated}")


    return df_missing, email_success, emails_generated
